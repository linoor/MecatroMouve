{"name":"MÃ©catromouve","tagline":"","body":"GoMouve\r\n=======\r\n**prototype version 0.1**\r\n\r\nThis document provides a tutorial on how to set up the micro-controller part of the [GoMouve](https://sites.google.com/site/20142015gr08/home) project, and explains how it works.\r\n\r\n## Introduction\r\nIt contains 2 Arduinos, one as *sender* (the moving target), the other as *receiver* (the camera).  \r\n*Sender* collects its altitude (barometer) and location (GPS) then sends to receiver. While *receiver* collects them as well as its own altitude, location, and direction (magnetometer). It then computes the angle the camera should turn.\r\n\r\n## Set Up\r\n#### Components\r\nFor *sender* and *receiver*, the following devices are required:\r\n##### Sender\r\n* Arduino Uno * 1\r\n* XBee & shield * 1\r\n* GPS (with antenna) * 1\r\n* Barometer * 1\r\n\r\n##### Receiver\r\n* Arduino Uno * 1\r\n* XBee & shield * 1\r\n* GPS (with antenna) * 1\r\n* Barometer * 1\r\n* ~~9DOF * 1~~\r\n* ~~Servo * 2~~\r\n\r\n*Current models: [XBee & shield](http://www.cooking-hacks.com/shop/arduino/arduino-xbee-802-15-4), [GPS](http://www.adafruit.com/product/746), [Barometer](http://www.adafruit.com/product/1893), [9DOF](http://www.adafruit.com/product/1714), [Servo](http://www.miniplanes.fr/servos/tower-pro/mini-servo-9g-towerpro-sg90-p-2995.html)*\r\n\r\n#### Wiring\r\n##### Sender\r\n![Alt text](https://dl.dropboxusercontent.com/u/17953813/img/sender.png \"sender's sketch\")\r\n##### Receiver\r\n![Alt text](https://dl.dropboxusercontent.com/u/17953813/img/receiver.png \"receiver's sketch\")\r\nNote:\r\n* Check the ports for ***SCL*** and ***SDA*** of your Arduino board\r\n* *The Adafruit 9DOF sensor is currently not in use.*\r\n* *The servo has been changed.\r\n\r\n#### Uploading Scripts\r\n1. Get scripts of *sender* and *receiver* from [here](https://github.com/linoor/MecatroMouve/tree/master) (each in `XBee/sender`,  `XBee/receiver`)\r\n2. Download and import required libraries (see below)\r\n3. Set `GPSRXPin` `GPSTXPin` values according to circuit (`GPSRXPin` connects the ***TX*** pin of GPS, and vice versa)\r\n4. ~~Set ports for Servos as first parameters in\r\n  `myservoVertical.attach(PORT_V, 500, 2400)` `myservoHorizontal.attach(PORT_H, 500, 2400)`~~\r\n5. Upload script to Arduino board\r\n  ***Remember to turn jumpers of XBee shields into USB mode*** *[ref](http://electronics.stackexchange.com/questions/25574/xbee-shield-turning-jumper-settings-into-on-off-xbee-usb-manual-switch)*\r\n6. Configure baudrate to `57600` for Serial Monitor\r\n\r\n#### Required Libraries\r\nGPS\r\n* ~~[TinyGPS++](https://github.com/mikalhart/TinyGPSPlus/releases)~~\r\n* [Adafruit_GPS](https://github.com/adafruit/Adafruit-GPS-Library)\r\n\r\nBarometer\r\n* [MPL3115A2](https://github.com/adafruit/Adafruit_MPL3115A2_Library)\r\n\r\n9DoF\r\n* [Adafruit_Sensor](https://github.com/adafruit/Adafruit_Sensor)\r\n* [Adafruit_LSM303_U](https://github.com/adafruit/Adafruit_LSM303DLHC)\r\n* [Adafruit_L3GD20_U](https://github.com/adafruit/Adafruit_L3GD20_U)\r\n\r\n## Explanation\r\n### Communication Process\r\n#### XBee Handshaking\r\n* In `sender.ino`:\r\n    ``` cpp\r\n    while (true)\r\n    {\r\n        Serial.print(\"A\");\r\n        delay(50);\r\n        while (Serial.available())\r\n        {\r\n            // Serial.println(\"Available\");\r\n            if (Serial.read() == 'B')\r\n            {\r\n                // Serial.println(\"Read B\");\r\n                Serial.println(\"Setup finished!\");\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n* In `receiver.ino`:\r\n    ``` cpp\r\n    while (true)\r\n    {\r\n        delay(10);\r\n        if (Serial.available())\r\n        {\r\n            if (Serial.read() == 'A')\r\n            {\r\n                for (int i = 0; i < 10; i++)\r\n                {\r\n                    Serial.print(\"B\");\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    ```\r\n\r\n1. The *sender* sends out `A` continuously.\r\n2. Once the *receiver* receives `A`, it returns `B` for 10 times and leaves the session.\r\n3. Once the *sender* receives `B`, handshaking ends.\r\n\r\nNote:\r\n* Pass the parameter to `Serial.print`(or `write`) as `string`, while\r\n\r\n#### Sending Data\r\n\r\nThe transmission of data between XBees is facilited with C++ data type `union`.\r\n\r\nFor example:\r\n\r\n```cpp\r\nunion bytes\r\n{\r\n    float f;\r\n    byte b[sizeof(float)];\r\n}\r\n```\r\n\r\nVariables `f` and `b` actually point to the same memory block (4 bytes in this case), which allows us to manipulate the data as `float` number, and to send data as byte over XBee.\r\n\r\n``` cpp\r\nbytes data;\r\n// manipulation of data\r\n// e.g. data.f = myPressure.readAltitude();\r\n\r\nSerial.write(data.b, sizeof(float));\r\n```\r\n\r\nTo handle each ideal data type of the sensor, we thereby implement this part with C++ template.\r\n\r\nEach data set should be sent at each refresh with a starting signal, a data type signal, and an ending signal to prevent `receiver` from parsing incorrectly due to data loss.\r\n\r\nAs in `sendData` function:\r\n``` cpp\r\ntemplate <typename T>\r\nvoid sendData(bytes<T> dataToSend[], int dataSize, String typeSignal)\r\n{\r\n    Serial.print(START_SIGNAL);\r\n    Serial.print(typeSignal);\r\n    for (int i = 0; i < dataSize; i++)\r\n    {\r\n        Serial.write(dataToSend[i].b, sizeof(T));\r\n    }\r\n    Serial.print(END_SIGNAL);\r\n}\r\n```\r\nThe current setting of protocal follows\r\n* `START_SIGNAL`: s\r\n* `END_SIGNAL`: e\r\n* `typeSignal`: a, g, d, i, l, f (as altitude, location (2D), debug, `int`, `long`, `float`)\r\n\r\n\r\n### Moving Camera\r\n#### Sender\r\n#### Receiver\r\n#### Formula\r\n\r\n## TODO\r\n* moving camera part (barometer first, then self-calibration of receiver, and finally with GPS location)\r\n* optimize handshaking\r\n\r\n*updated by Eric Chiu 05.05.15*\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}